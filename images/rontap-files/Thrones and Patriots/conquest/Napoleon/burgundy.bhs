include "ctw_lib.bhs"

void conquest ClosestCity(int jacob_int);
void conquest AttackHere(int spot_int);

conquest
{

labels {
  HUMAN = 1,
  JACOB = 2,
  ROYAL = 3,
  lyonsx_int = 196,
  lyonsy_int = 183,
  dijonx_int = 128,
  dijony_int = 109,
  troyesx_int = 29,
  troyesy_int = 46
}

static int big_int;
static int old_attack;
static int old_int;
static int lyons_int = find_city_id("Lyons");
static int dijon_int = find_city_id("Dijon");
static int troyes_int = find_city_id("Troyes");
static int toggle_int = 0;
static int diff_int = get_difficulty();

static int diffmod_int;
static int bigroyalspawn_int = 200;
static int idle_int;
int spot_int;
int numjacob_int;
int numroyal_int;
int numcitizen_int;
int numminuteman_int;
int royal_int;
int jacob_int;
int citizen_int;
int minuteman_int;
int x_int;
int y_int;
int random_int;
int city_int;
int losses;

run_once {
if (get_ctw_campaign() == "Napoleon") {
  napoleon_rules();
}
  ctw_add_objective_text($S("Do not let your enemies take any cities."), "revolt_obj", "");
  gain_tech(HUMAN, "minuteman");
  disable_type("spy");
  disable_type("general");
  disable_tech(HUMAN, "allegiance");
  disable_city_defeat(ROYAL);
  disable_city_defeat(JACOB);
  disable_trigger("crtimer_trg");
  //set_victory_message($S("Most of the revolts have subsided.  Your power is in tact!"));
  set_timer("royalspawn_tmr", 70 - (diff_int*5));
  set_timer("jacobspawn_tmr", 180 - (diff_int*5));
  set_timer("bigroyalspawn_tmr", bigroyalspawn_int);
  if (diff_int < 3) diffmod_int = 1;
  else diffmod_int = 2;
  
  create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "musketeers", diffmod_int);
  create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "horse guard grenadier", diffmod_int);
  create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "hussar", diffmod_int);

  for (losses = get_num_times_played("Custom", "Keeping the Peace"); losses > 0; losses--){
    create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "musketeers", 3);
    create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "fusiliers", 2);
    create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "horse guard grenadier", 1);
    create_unit_upgrade(HUMAN, dijonx_int, dijony_int, "carabineer", 1);
  }

  take_good(HUMAN, "food", 25*diff_int);
  take_good(HUMAN, "timber", 25*diff_int);
  take_good(HUMAN, "metal", 25*diff_int);
  take_good(HUMAN, "wealth", 25*diff_int);

  if (diff_int < 4) {
    place_building_upgrade(HUMAN, "barracks", lyons_int);
    place_building_upgrade(HUMAN, "barracks", troyes_int);
  }
  if (diff_int < 3) {
    disable_trigger ("jacobspawn_trg");
    place_building_upgrade(HUMAN, "tower", lyons_int);
    place_building_upgrade(HUMAN, "tower", dijon_int);
    place_building_upgrade(HUMAN, "tower", troyes_int);
  }
  if (diff_int < 2) {
    disable_trigger ("bigroyalspawn_trg");
  }
} // run_once

// **************************
// Peasants revolt and attack
trigger jacobspawn_trg(timer_expired("jacobspawn_tmr")) {
  show_notice($S("THE WORKING CLASS IS REVOLTING!"), "city_under_attack_notice", HUMAN);
  for (numcitizen_int = num_type(HUMAN, "citizen"); numcitizen_int > 0; numcitizen_int--) {
    if (toggle_int == 2) {
      citizen_int = find_all_unit(HUMAN, "citizen");
      x_int = object_position_x(HUMAN, citizen_int);
      y_int = object_position_y(HUMAN, citizen_int);
      jacob_int = create_unit_upgrade(JACOB, x_int, y_int, "minuteman", 1);
      unit_stance_order(JACOB, jacob_int, "raid");
      ClosestCity(jacob_int);
      kill_unit_anim(HUMAN, citizen_int, 1);
      toggle_int = 0;
    } // if (toggle_int == 2)
    else toggle_int++;
  } // for (numcitizen_int
  for (numminuteman_int = num_type(HUMAN, "minuteman"); numminuteman_int > 0; numminuteman_int--) {
    if (toggle_int == 2) {
      minuteman_int = find_all_unit(HUMAN, "minuteman");
      x_int = object_position_x(HUMAN, minuteman_int);
      y_int = object_position_y(HUMAN, minuteman_int);
      jacob_int = create_unit_upgrade(JACOB, x_int, y_int, "minuteman", 1);
      unit_stance_order(JACOB, jacob_int, "raid");
      ClosestCity(jacob_int);
      kill_unit_anim(HUMAN, minuteman_int, 1);
      toggle_int = 0;
    } // if (toggle_int == 1)
    else toggle_int++;
  } // for (numminuteman_int
  set_timer("idlejacob_tmr", 20);
  set_timer("jacobspawn_tmr", rand_int(150 - (5*diff_int), 225 - (5*diff_int)));
  enable_trigger ("jacobspawn_trg");
} // trigger jacobspawn_trg

// *************************
// Royalists mount an attack
trigger royalspawn_trg(timer_expired("royalspawn_tmr")){
  random_int = rand_int(1, 6);
  if (random_int == old_int) {
    random_int += 3;
  }
  if (random_int > 6) {
    random_int += -6;
  }
  old_int = random_int;
  switch (random_int) {
    case 1:
      x_int = 236;
      y_int = 200;
      spot_int = 1;
      break;
    case 2:
      x_int = 150;
      y_int = 236;
      spot_int = 2;
      break;
    case 3:
      x_int = 110;
      y_int = 4;
      spot_int = 4;
      break;
    case 4:
      x_int = 236;
      y_int = 80;
      spot_int = 5;
      break;
    case 5:
      x_int = 4;
      y_int = 100;
      spot_int = 6;
      break;
    case 6:
      x_int = 60;
      y_int = 4;
      spot_int = 7;
      break;
  } // switch (random_int)
  random_int = rand_int(1, 9);
  if (random_int == old_attack) {
    random_int+= 4;
    if (random_int > 9) {
      random_int+= -9;
    }
  }
  old_attack = random_int;
  switch (random_int) {
    case 1:
    case 2:
    case 3:
      clear_group(ROYAL);
      create_unit_upgrade(ROYAL, x_int, y_int, "Horse Guard Grenadier", 2);
      create_unit_in_group(ROYAL, x_int, y_int, "Hussar", 1);
      group_stance_order(ROYAL, "raid");
      AttackHere(spot_int);
      break;
    case 4:
    case 5:
    case 6:
      clear_group(ROYAL);
      create_unit_upgrade(ROYAL, x_int, y_int, "Musketeers", 1);
      create_unit_in_group(ROYAL, x_int, y_int, "Fusiliers", 2);
      AttackHere(spot_int);
      break;
    case 7:
      if (diff_int > 2) {
        clear_group(ROYAL);
        royal_int = create_unit_upgrade(ROYAL, x_int, y_int, "Cannon", 1);
        AttackHere(spot_int);
        clear_group(ROYAL);
        create_unit_upgrade(ROYAL, x_int, y_int, "Musketeers", 1);
        //create_unit_in_group(ROYAL, x_int, y_int, "Fusiliers", 1);
        group_guard_order(ROYAL, ROYAL, royal_int);
      } // if (diff_int > 2)
      break;
    case 8:
      if (diff_int > 4) {
        clear_group(ROYAL);
        royal_int = create_unit_upgrade(ROYAL, x_int, y_int, "Cannon", 1);
        AttackHere(spot_int);
        clear_group(ROYAL);
        create_unit_upgrade(ROYAL, x_int, y_int, "Musketeers", 1);
        create_unit_in_group(ROYAL, x_int, y_int, "Fusiliers", 1);
        group_guard_order(ROYAL, ROYAL, royal_int);
      } // if (diff_int > 4)
      break;
    case 9:
      if (diff_int > 5) {
        clear_group(ROYAL);
        create_unit_upgrade(ROYAL, x_int, y_int, "Musketeers", 1);
        //create_unit_in_group(ROYAL, x_int, y_int, "Fusiliers", 1);
        AttackHere(spot_int);
      } // if (diff_int > 5)
      break;
  } // switch (random_int)

  enable_trigger ("royalspawn_trg");
  if (time_later_than(10) && !time_later_than(5)) {
    set_timer("royalspawn_tmr", 95 - (diff_int*5));
  } // if (time_later_than(10)
  else if (time_later_than(5)) {
    set_timer("royalspawn_tmr", 90 - (diff_int*6));
  } // else if (time_later_than(5)
  else {
    set_timer("royalspawn_tmr", 100 - (diff_int*4));
  } // else
} // trigger royalspawn_trg

// ** Spawn a big encounter
trigger bigroyalspawn_trg(timer_expired("bigroyalspawn_tmr")) {
  random_int = rand_int(1, 6);
  if (random_int == big_int) {
    random_int+=2;
    if (random_int > 6) {
      random_int+=-6;
    }
  }
  big_int = random_int;
  switch (random_int) {
    case 1:
      x_int = 236;
      y_int = 200;
      spot_int = 1;
      break;
    case 2:
      x_int = 150;
      y_int = 236;
      spot_int = 2;
      break;
    case 3:
      x_int = 110;
      y_int = 4;
      spot_int = 4;
      break;
    case 4:
      x_int = 236;
      y_int = 80;
      spot_int = 5;
      break;
    case 5:
      x_int = 4;
      y_int = 100;
      spot_int = 6;
      break;
    case 6:
      x_int = 60;
      y_int = 4;
      spot_int = 7;
      break;
  } // switch (random_int)
  clear_group(ROYAL);
  create_unit_upgrade(ROYAL, x_int, y_int, "Cannon", diff_int);
  AttackHere(spot_int);
  clear_group(ROYAL);
  create_unit_upgrade(ROYAL, x_int, y_int, "Musketeers", diffmod_int);
  create_unit_in_group(ROYAL, x_int, y_int, "Fusiliers", diffmod_int);
  create_unit_in_group(ROYAL, x_int, y_int, "Horse Guard Grenadier", diffmod_int);
  group_guard_order(ROYAL, ROYAL, royal_int);
  enable_trigger ("bigroyalspawn_trg");
  if (bigroyalspawn_int < 100) bigroyalspawn_int = 100;
  else bigroyalspawn_int = bigroyalspawn_int - (3*diff_int);
  set_timer("bigroyalspawn_tmr", bigroyalspawn_int);
} // trigger bigroyalspawn_trg

// **Take the cities if reduced
trigger cityreduced_trg(object_health(HUMAN, lyons_int) == 0 || object_health(HUMAN, dijon_int) == 0 || object_health(HUMAN, troyes_int) == 0) {
  if (object_health(HUMAN, lyons_int) == 0)
    city_int = lyons_int;
  else if (object_health(HUMAN, dijon_int) == 0)
    city_int = dijon_int;
  else city_int = troyes_int;
  x_int = object_position_x(HUMAN, city_int);
  y_int = object_position_y(HUMAN, city_int);
  for (numroyal_int = num_units(ROYAL); numroyal_int > 0; numroyal_int--) {
    unit_attack_to_order(ROYAL, find_unit(ROYAL, ""), x_int, y_int);
  } // for (numroyal_int
  enable_trigger("crtimer_trg");
  set_timer("crtimer_tmr", 30);
} // trigger cityreduced_trg

trigger crtimer_trg(timer_expired("crtimer_tmr")) {
  enable_trigger("cityreduced_trg");
} // trigger crtimer_trg

// *******************
// Clean up idle units
royal_int = find_idle_military(ROYAL);
trigger idleroyal1_trg(royal_int > -1) {
  idle_int = royal_int;
  set_timer("idleroyal2_tmr", 10);
  enable_trigger ("idleroyal2_trg");
} // trigger idleroyal1_trg
trigger idleroyal2_trg(timer_expired("idleroyal2_tmr")) {
  if (is_idle(ROYAL, idle_int)) {
    unit_attack_to_order(ROYAL, idle_int, dijonx_int, dijony_int);
  } // if (is_idle
  enable_trigger ("idleroyal1_trg");
} // trigger idleroyal2_trg
}

void conquest ClosestCity(int jacob_int) {
  int x_int = object_position_x(JACOB, jacob_int);
  int y_int = object_position_y(JACOB, jacob_int);
  int tempx_int = x_int - lyonsx_int;
  int tempy_int = y_int - lyonsy_int;
  int distlyons_int;
  int distdijon_int;
  int disttroyes_int;
  distlyons_int = tempx_int*tempx_int + tempy_int*tempy_int;
  tempx_int = x_int - dijonx_int;
  tempy_int = y_int - dijony_int;
  distdijon_int = tempx_int*tempx_int + tempy_int*tempy_int;
  tempx_int = x_int - troyesx_int;
  tempy_int = y_int - troyesy_int;
  disttroyes_int = tempx_int*tempx_int + tempy_int*tempy_int;
  if (distlyons_int >= distdijon_int) {
    if (distlyons_int >= disttroyes_int) {
      unit_attack_to_order(JACOB, jacob_int, lyonsx_int, lyonsy_int);
    } // if (distlyons_int >= disttroyes_int
    else {
      unit_attack_to_order(JACOB, jacob_int, troyesx_int, troyesy_int);
    } // else
  } // if (distlyons_int >= distdijon_int
  else {
    if (distdijon_int >= disttroyes_int) {
      unit_attack_to_order(JACOB, jacob_int, dijonx_int, dijony_int);
    } // if (distdijon_int >= disttroyes_int
    else {
      unit_attack_to_order(JACOB, jacob_int, troyesx_int, troyesy_int);
    } // else
  } // else
} // int scenerio ClosestCity

void conquest AttackHere(int spot_int) {
  switch (spot_int) {
    case 1:
      group_attack_to_order(ROYAL, lyonsx_int, lyonsy_int);
      break;
    case 2:
      group_attack_to_order(ROYAL, lyonsx_int, lyonsy_int);
      break;
    case 3:
      group_attack_to_order(ROYAL, dijonx_int, dijony_int);
      break;
    case 4:
      group_attack_to_order(ROYAL, dijonx_int, dijony_int);
      break;
    case 5:
      group_attack_to_order(ROYAL, troyesx_int, troyesy_int);
      break;
    case 6:
      group_attack_to_order(ROYAL, troyesx_int, troyesy_int);
      break;
  } // switch (spot_int)
} // void scenario AttackHere